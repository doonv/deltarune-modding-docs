# Preprocessing script that combines all scripts and removes #r directives

# Generated by Gemini because I hate writing python. fuck python


import os
import re

# --- Configuration ---
# The entry point scripts for preprocessing.
MAIN_SCRIPTS = ["main.csx"]

OUTPUT_FOLDER = "build"

# The FILENAME of the special script to IGNORE during #load processing.
# Any #load directive pointing to this filename will be skipped.
GLOBAL_SCRIPT_FILENAME_TO_IGNORE = "_globals.csx"
# --- End of Configuration ---

# Regex to find directives
LOAD_DIRECTIVE_REGEX = re.compile(r'^\s*#load\s+"([^"]+)"\s*$')
REFERENCE_DIRECTIVE_REGEX = re.compile(r'^\s*#r\s+.*$')
USING_DIRECTIVE_REGEX = re.compile(r'^\s*using\s+[\w\.\s=]+;')

def process_script_recursively(file_path, collected_usings, processed_files):
    """
    Recursively processes a C# script file, returning its code content while
    populating the global 'collected_usings' set.

    Args:
        file_path (str): The absolute path to the script file to process.
        collected_usings (set): A set that will be populated with all found using statements.
        processed_files (set): A set of already processed files to prevent infinite recursion.

    Returns:
        str: The combined C# code from this file and its children, with directives handled.
    """
    file_path = os.path.abspath(file_path)

    if file_path in processed_files:
        print(f"-> Skipping already processed file: {os.path.basename(file_path)}")
        return ""

    print(f"-> Processing file: {os.path.basename(file_path)}")
    processed_files.add(file_path)

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except FileNotFoundError:
        error_msg = f"// ERROR: Could not load file '{os.path.basename(file_path)}'\n"
        print(f"!! ERROR: File not found: {file_path}")
        return error_msg

    code_parts = []
    current_dir = os.path.dirname(file_path)

    for line in lines:
        if REFERENCE_DIRECTIVE_REGEX.match(line):
            print(f"   -> Removing reference: {line.strip()}")
            continue  # Remove #r directive

        if USING_DIRECTIVE_REGEX.match(line):
            print(f"   -> Found using: {line.strip()}")
            collected_usings.add(line.strip())
            continue  # Extract using directive and remove from code body

        match_load = LOAD_DIRECTIVE_REGEX.match(line)
        if match_load:
            relative_path = match_load.group(1).replace('\\', '/')
            
            # THE KEY FIX: Check if the loaded filename is the one to ignore.
            if os.path.basename(relative_path) == GLOBAL_SCRIPT_FILENAME_TO_IGNORE:
                print(f"   -> Ignoring special file: #load \"{relative_path}\"")
                continue # Skip this directive entirely

            # It's a regular #load, so process it recursively.
            print(f"   -> Found #load '{relative_path}'. Inlining content...")
            absolute_path_to_load = os.path.join(current_dir, relative_path)
            sub_code = process_script_recursively(absolute_path_to_load, collected_usings, processed_files)
            code_parts.append(sub_code)
        else:
            # This is a regular line of code.
            code_parts.append(line)

    return "".join(code_parts)

def main():
    """
    Main function to drive the preprocessing.
    """
    print("Starting C# script preprocessing...")
    for main_script in MAIN_SCRIPTS:
        if not os.path.exists(main_script):
            print(f"!! ERROR: Main script '{main_script}' not found. Aborting.")
            exit(1);

        # These sets will be populated by the recursive function.
        final_usings = set()
        processed_files = set()

        # A single, clean, recursive call starts the whole process.
        code_body = process_script_recursively(
            os.path.abspath(main_script),
            final_usings,
            processed_files
        )

        # 1. Assemble the `using` header
        sorted_usings = sorted(list(final_usings))
        using_header = "\n".join(sorted_usings)

        # 2. Combine and write to the output file
        final_script_content = f"{using_header}\n\n{code_body.lstrip()}"

        if OUTPUT_FOLDER and not os.path.exists(OUTPUT_FOLDER):
            os.makedirs(OUTPUT_FOLDER)
            print(f"Created output directory: {OUTPUT_FOLDER}")

        file_path = os.path.join(OUTPUT_FOLDER, os.path.basename(main_script))
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(final_script_content)
        print(file_path)

    print(f"\nâœ… Preprocessing complete.")

if __name__ == "__main__":
    main()